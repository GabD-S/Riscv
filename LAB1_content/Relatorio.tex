\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{float}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{colortbl}
\geometry{a4paper, margin=1in}

\lstset{
  basicstyle=\small\ttfamily,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{green!40!black},
  stringstyle=\color{purple},
  showstringspaces=false,
}

% Definição de linguagem para Assembly (RISC-V) no listings
\lstdefinelanguage{Assembly}{
    morekeywords={.text,.data,.globl,li,la,addi,add,sub,mul,div,rem,
        slli,srli,srai,andi,ori,xori,andi,or,xor,slt,slti,beq,bne,blt,bge,bgt,
        j,jal,jalr,ret,ecall,lw,sw,lb,lh,lb,sb,flw,fsw,fmv.d,fcvt.d.w,fmul.d,fadd.d,fsub.d,fdiv.d,
        fsd,fld,csrr,csrw,mv,lui,auipc},
    sensitive=true,
    morecomment=[l]{#},
}

\hypersetup{
  colorlinks=true,
  linkcolor=black,
  urlcolor=blue,
  pdftitle={Laboratório 1 - Assembly RISC-V},
  pdfauthor={Grupo}
}

\begin{document}

% -----------------------------
% capa (estilo semelhante ao OAC_LAB1)
% -----------------------------
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        \includegraphics[width=5cm]{Lab_1/Logo_UnB.png}\\[1cm]

        {\LARGE \textbf{Universidade de Brasília}}\\[4pt]
        {\large Departamento de Ciência da Computação}\\[12pt]
        {\Large \textbf{Disciplina: CIC0099 -- Organização e Arquitetura de Computadores -- Unificado}}\\[20pt]

        {\huge \textbf{Laboratório 1}}\\[6pt]
        {\Large \textbf{Assembly RISC-V}}\\[2cm]

        \textbf{Grupo:} \\[4pt]
        \begin{tabular}{l}
            
            Gabriel de Sousa -- 211056000 \\
            Ana Luísa Reis Nascente -- 211045688 \\
            Guilherme Henrique Oliveira Araujo -- (matrícula) \\
            
        \end{tabular}

        \vfill

        

        \vspace{0.8cm}
        \today
    \end{center}
\end{titlepage}

\pagenumbering{roman}
\tableofcontents
\newpage

\pagenumbering{arabic}

% -----------------------------
% introducao (estilo do relatório)
% -----------------------------
\section*{Introdução}
\addcontentsline{toc}{section}{Introdução}

Este relatório segue a estrutura solicitada no enunciado do Laboratório 1 (OAC\_LAB1). O objetivo principal é desenvolver habilidades práticas em linguagem Assembly RISC-V utilizando o simulador RARS e ferramentas de compilação cruzada. As atividades envolvem: implementação e análise de algoritmos em Assembly, medição de desempenho usando CSRs, comparação do código gerado pelo compilador cruzado gcc com diferentes níveis de otimização, e implementação da Transformada Discreta de Fourier (DFT) em Assembly.

O relatório está organizado na forma de \emph{resposta ao item}, contendo apenas os itens que valem ponto, e mantendo as perguntas explicitamente conforme solicitado no enunciado. As seções seguintes reproduzem as perguntas do enunciado para que as respostas possam ser inseridas diretamente abaixo de cada item.

% -----------------------------
% objetivos (copiado/compactado)
% -----------------------------
\section*{Objetivos}
\begin{itemize}
    \item Familiarizar o aluno com o Simulador/Montador RARS;
    \item Desenvolver a capacidade de codificação de algoritmos em linguagem Assembly;
    \item Desenvolver a capacidade de análise de desempenho de algoritmos em Assembly;
    \item Familiarizar o aluno com a compilação C para Assembly RISC-V RV32IMF.
\end{itemize}

% -----------------------------
% parte 1 - enunciado reproduzido
% -----------------------------
\section*{(2.5) 1) Simulador/Montador RARS}
Faça o download e deszipe o arquivo \texttt{Lab1.zip} disponível no Moodle.

\subsection*{(0.0) 1.1) No diretório Arquivos, abra o \texttt{Rars16\_Custom1} e carregue o programa de ordenamento \texttt{sort.s}.}
Dado o vetor:
\[
V[30]=\{9,2,5,1,8,2,4,3,6,7,10,2,32,54,2,12,6,3,1,78,54,23,1,54,2,65,3,6,55,31\}
\]

\begin{enumerate}
    \item[(a)] ordená-lo em ordem crescente e contar o número de instruções por tipo e o número total exigido pelo procedimento \texttt{sort}. Qual o tamanho em bytes do código executável? E da memória de dados usada?
    \item[(b)] Modifique o programa para ordenar o vetor em ordem decrescente e contar o número de instruções por tipo e o número total exigido pelo procedimento \texttt{sort}.
    \item[(c)] Usando os contadores de instruções e tempo do Banco de Registradores CSR (veja no final), meça novamente a quantidade de instruções executadas e o tempo de execução dos itens (a) e (b).
\end{enumerate}

\subsection*{(2.5) 1.2) Considere a execução deste algoritmo em um processador RISC-V com frequência de clock de 50MHz que necessita 1 ciclo de clock para a execução de cada instrução $(CPI=1)$.}
Para os vetores de entrada de $n$ elementos já ordenados $V_{o}[n]=\{1,2,3,4,...,n\}$ e ordenados inversamente $V_{i}[n]=\{n,n-1,n-2,...,2,1\}$:

\begin{enumerate}
    \item[(1.5) a)] Para o procedimento \texttt{sort}, escreva as equações dos tempos de execução, $t_{o}(n)$ e $t_{i}(n)$, em função de $n$.
    \item[(1.0) b)] Para $n=\{10,20,30,40,50,60,70,80,90,100\}$, plote (em escala!) as duas curvas, $t_{o}(n)$ e $t_{i}(n)$, em um mesmo gráfico $n \times t$. Comente os resultados obtidos.
\end{enumerate}

\section*{Resposta à Questão 1.2}

A seguir são apresentadas as respostas para os itens da questão 1.2, com base no relatório fornecido.

\subsection*{1.2(a) Equações do Tempo de Execução}

As equações teóricas para o tempo de execução do algoritmo \texttt{SORT} foram desenvolvidas para o melhor caso (vetor já ordenado) e o pior caso (vetor ordenado de forma inversa), considerando um processador RISC-V com frequência de 50 MHz e CPI=1.

\subsubsection*{Caso Melhor (vetor já ordenado $V_{o}[n]=\{1,2,3,...,n\}$)}
\begin{itemize}
    \item \textbf{Número de ciclos (instruções)}:
    $$ C_{best}(n) = 11n + 14 $$
    \item \textbf{Tempo em microssegundos ($\mu s$)}, dado $f=50 \times 10^{6} Hz$:
    $$ t_{o}(n) = \frac{C_{best}(n)}{f} = \frac{11n + 14}{50 \times 10^{6}}s = \frac{11n + 14}{50}\mu s $$
\end{itemize}

\subsubsection*{Caso Pior (vetor inversamente ordenado $V_{i}[n]=\{n,n-1,...,1\}$)}
\begin{itemize}
    \item \textbf{Número de ciclos}:
    $$ C_{worst}(n) = \frac{11}{2}n^{2} + \frac{11}{2}n + 3 $$
    \item \textbf{Tempo em microssegundos ($\mu s$)}:
    $$ t_{i}(n) = \frac{C_{worst}(n)}{f} = \frac{\frac{11}{2}n^{2} + \frac{11}{2}n + 3}{50 \times 10^{6}}s = \frac{\frac{11}{2}n^{2} + \frac{11}{2}n + 3}{50}\mu s $$
\end{itemize}

\subsection*{1.2(b) Dados para o Gráfico e Análise}

\subsubsection*{Dados Calculados}
A tabela abaixo apresenta os tempos de execução calculados para o melhor caso ($t_o(n)$) e o pior caso ($t_i(n)$) para os valores de $n$ de 10 a 100.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{n} & \textbf{$t_o(n) (\mu s)$} & \textbf{$t_i(n) (\mu s)$} \\
\hline
10 & 2.48 & 12.16 \\
20 & 4.68 & 46.26 \\
30 & 6.88 & 102.36 \\
40 & 9.08 & 180.46 \\
50 & 11.28 & 280.56 \\
60 & 13.48 & 402.66 \\
70 & 15.68 & 546.76 \\
80 & 17.88 & 712.86 \\
90 & 20.08 & 900.96 \\
100 & 22.28 & 1111.06 \\
\hline
\end{tabular}
\caption{Tempos de execução calculados para diferentes valores de n.}
\end{table}

\subsubsection*{Gráfico Comparativo}

A Figura \ref{fig:tempo_execucao} apresenta a comparação entre os tempos de execução do melhor caso ($t_o(n)$) e do pior caso ($t_i(n)$) em função do tamanho do vetor $n$.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{grafico_tempo_execucao.png}
\caption{Tempo de execução vs. tamanho do vetor n para melhor e pior caso.}
\label{fig:tempo_execucao}
\end{figure}

\subsubsection*{Análise dos Resultados}

Conforme observado na Figura \ref{fig:tempo_execucao}, a curva de melhor caso ($t_o(n)$) demonstra um crescimento linear em relação a $n$, resultado direto da equação $t_o(n) = \frac{11n + 14}{50}$. Em contraste, a curva de pior caso ($t_i(n)$) apresenta um crescimento quadrático, tornando-se significativamente maior à medida que $n$ aumenta, conforme esperado pela equação $t_i(n) = \frac{\frac{11}{2}n^{2} + \frac{11}{2}n + 3}{50}$. 

Esta análise ressalta a sensibilidade do algoritmo de ordenação à disposição inicial dos dados, sendo muito eficiente para entradas quase ordenadas, mas impraticável para entradas grandes e inversamente ordenadas. Por exemplo, para $n=100$, o tempo do pior caso ($1111.06\,\mu s$) é aproximadamente 50 vezes maior que o tempo do melhor caso ($22.28\,\mu s$).

\subsection*{Código em GNU Octave para Geração do Gráfico}

A seguir é apresentado o código em GNU Octave utilizado para gerar o gráfico da Figura \ref{fig:tempo_execucao}.

\begin{verbatim}
% Valores de n (tamanho do vetor)
n = 10:10:100;

% Equacoes de ciclos para melhor e pior caso
C_best = 11*n + 14;
C_worst = 0.5*11*n.^2 + 0.5*11*n + 3;

% Conversao para tempo em microssegundos (us)
t_best = C_best / 50;
t_worst = C_worst / 50;

% Plotagem do grafico
figure;
plot(n, t_best, 'bo-', 'LineWidth', 2, 'DisplayName', 't_o(n): melhor caso');
hold on;
plot(n, t_worst, 'rx-', 'LineWidth', 2, 'DisplayName', 't_i(n): pior caso');
hold off;

% Configuracao do grafico
xlabel('Tamanho do vetor n');
ylabel('Tempo de execucao (\mus)');
title('Tempo de Execucao vs. n');
legend('show');
grid on;
\end{verbatim}

% ----------------------------------------
% SEÇÃO 2 - COMPILADOR CRUZADO GCC
% ----------------------------------------

\section*{2) Compilador cruzado GCC}

Um compilador cruzado (\textit{cross compiler}) compila um código fonte para uma arquitetura diferente daquela da máquina em que está sendo utilizado. Você pode baixar gratuitamente os compiladores gcc para todas as arquiteturas (RISC-V, ARM, MIPS, x86 etc.) e instalar na sua máquina, sendo que o código executável gerado apenas poderá ser executado em uma máquina que possuir o processador para qual foi compilado. No gcc, a diretiva de compilação \texttt{-S} faz com que o processo pare com a geração do arquivo em Assembly e a diretiva \texttt{-march} permite definir a arquitetura a ser utilizada.

\textbf{Exemplos:}
\begin{verbatim}
riscv64-unknown-elf-gcc -S -march=rv32imf -mabi=ilp32f  # RV32IMF
arm-eabi-gcc -S -march=armv7                            # ARMv7
gcc -S -m32                                              # x86 32-bit
\end{verbatim}

\subsection*{2.1 Enunciado}

Dado o programa \texttt{sortc.c}, compile-o com a diretiva \texttt{-O0} e obtenha o arquivo \texttt{sortc.s}. Indique as modificações necessárias no código Assembly gerado para que possa ser executado corretamente no Rars. 

\textbf{Dica:} Uso de Assembly em um programa em C. Use a função \texttt{show} definida no \texttt{sort.s} para não precisar implementar a função \texttt{printf}, conforme mostrado no \texttt{sortc\_mod.c}.

\subsection*{2.2 Modificações Necessárias no Código Assembly Gerado (-O0)}
Para executar o código Assembly gerado pelo compilador (com diretiva -O0) no RARS, as seguintes modificações foram necessárias:
\begin{enumerate}
    \item \textbf{Substituição de chamadas de funções:} A instrução \texttt{call} gerada pelo compilador não é suportada diretamente pelo RARS. É necessário substituí-la por \texttt{jal ra, function\_name}.
    \item \textbf{Substituição de argumentos:} O compilador online gerou \texttt{.LANCHOR0} em diversos casos para se referir ao vetor. Não sendo suportado pelo RARS e necessitando da troca pelo vetor \texttt{v} declarado.
    \item \textbf{Ajustes nos endereços de memória:} O código gerado utiliza diretivas como \texttt{\%hi} e \texttt{\%lo} para carregar endereços. No RARS, é mais prático usar a pseudoinstrução \texttt{la} (load address), mas o RARS entende a chamada mesmo assim.
    \item \textbf{Adição de chamada de sistema para encerramento:} No RARS, é necessário adicionar uma chamada de sistema para encerrar o programa corretamente. O compilador não os adiciona.
    \begin{lstlisting}[language=Assembly]
li a7, 10
ecall
    \end{lstlisting}
    \item \textbf{Simplificação do gerenciamento de pilha:} O código gerado pelo compilador com -O0 faz uso excessivo da pilha, o que pode ser simplificado para melhorar o desempenho.
    \item \textbf{Adaptação da função show:} A função \texttt{show} foi adaptada para usar \texttt{ecall} do RARS para a impressão dos valores, ao invés de chamar a função \texttt{printf} do C.
    \item \textbf{Remoção de instruções \texttt{nop} desnecessárias:} O compilador gerou instruções \texttt{nop} para alinhamento, que podem ser removidas no RARS.
\end{enumerate}

\subsection*{2.3 Comparação entre Diferentes Níveis de Otimização}
Foram analisados três arquivos Assembly gerados com diferentes níveis de otimização:

\begin{table}[h!]
    \centering
    \small
    \begin{tabular}{|l|l|r|r|}
        \hline
        \textbf{Arquivo} & \textbf{Otimização} & \textbf{Instruções} & \textbf{Tamanho} \\
        \hline
        2\_3\_O0.asm & -O0 (Sem otimização) & 10103 & 3.817 bytes \\
        2\_3\_O3.asm & -O3 (Otimização máxima) & 2484 & 2.152 bytes \\
        2\_3\_Os.asm & -Os (Otimização p/ tamanho) & 4406 & 2.543 bytes \\
        \hline
    \end{tabular}
    \caption{Comparativo entre diferentes níveis de otimização}
\end{table}

A Figura \ref{fig:otimizacao_comparacao} apresenta uma visualização gráfica dos dados da Tabela 5, permitindo uma comparação imediata do impacto de cada nível de otimização tanto no número de instruções executadas quanto no tamanho do arquivo gerado.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{grafico_otimizacao_comparacao.png}
\caption{Comparação visual entre níveis de otimização: número de instruções e tamanho do arquivo.}
\label{fig:otimizacao_comparacao}
\end{figure}

Observa-se que a otimização \texttt{-O3} apresenta a melhor performance em termos de instruções executadas (redução de 75\%), enquanto \texttt{-Os} oferece o melhor compromisso entre tamanho e desempenho.

\subsection*{2.4 Análise do Código Sem Otimização (-O0)}
\begin{lstlisting}[language=Assembly, caption={Código Assembly gerado com -O0}]
.data
v:
.word 9, 2, 5, 1, 8, 2, 4, 3, 6, 7
.word 10, 2, 32, 54, 2, 12, 6, 3, 1, 78
.word 54, 23, 1, 54, 2, 65, 3, 6, 55, 31

.text
main:
addi sp, sp, -16
sw ra, 12(sp)
sw s0, 8(sp)
addi s0, sp, 16
li a1, 30
lui a5, %hi(v)
addi a0, a5, %lo(v)
call show
li a1, 30
lui a5, %hi(v)
addi a0, a5, %lo(v)
call sort
li a1, 30
lui a5, %hi(v)
addi a0, a5, %lo(v)
call show
li a5, 0
mv a0, a5
lw ra, 12(sp)
lw s0, 8(sp)
addi sp, sp, 16
li a7, 10
ecall

show:
addi sp, sp, -32
sw ra, 28(sp)
sw s0, 24(sp)
addi s0, sp, 32
sw a0, -20(s0)
sw a1, -24(s0)
lw a5, -20(s0)
lw a4, -24(s0)
mv t0, a5
mv t1, a4
mv t2, zero
loop1:
beq t2, t1, fim1
li a7, 1
lw a0, 0(t0)
ecall
li a7, 11
li a0, 9
ecall
addi t0, t0, 4
addi t2, t2, 1
j loop1
fim1:
li a7, 11
li a0, 10
ecall
nop
lw ra, 28(sp)
lw s0, 24(sp)
addi sp, sp, 32
jr ra

swap:
addi sp, sp, -48
sw ra, 44(sp)
sw s0, 40(sp)
addi s0, sp, 48
sw a0, -36(s0)
sw a1, -40(s0)
lw a5, -40(s0)
slli a5, a5, 2
lw a4, -36(s0)
add a5, a4, a5
lw a5, 0(a5)
sw a5, -20(s0)
lw a5, -40(s0)
addi a5, a5, 1
slli a5, a5, 2
lw a4, -36(s0)
add a4, a4, a5
lw a5, -40(s0)
slli a5, a5, 2
lw a3, -36(s0)
add a5, a3, a5
lw a4, 0(a4)
sw a4, 0(a5)
lw a5, -40(s0)
addi a5, a5, 1
slli a5, a5, 2
lw a4, -36(s0)
add a5, a4, a5
lw a4, -20(s0)
sw a4, 0(a5)
nop
lw ra, 44(sp)
lw s0, 40(sp)
addi sp, sp, 48
jr ra

sort:
addi sp, sp, -48
sw ra, 44(sp)
sw s0, 40(sp)
addi s0, sp, 48
sw a0, -36(s0)
sw a1, -40(s0)
sw zero, -20(s0)
j .L4
.L8:
lw a5, -20(s0)
addi a5, a5, -1
sw a5, -24(s0)
j .L5
.L7:
lw a1, -24(s0)
lw a0, -36(s0)
call swap
lw a5, -24(s0)
addi a5, a5, -1
sw a5, -24(s0)
.L5:
lw a5, -24(s0)
blt a5, zero, .L6
lw a5, -24(s0)
slli a5, a5, 2
lw a4, -36(s0)
add a5, a4, a5
lw a4, 0(a5)
lw a5, -24(s0)
addi a5, a5, 1
slli a5, a5, 2
lw a3, -36(s0)
add a5, a3, a5
lw a5, 0(a5)
bgt a4, a5, .L7
.L6:
lw a5, -20(s0)
addi a5, a5, 1
sw a5, -20(s0)
.L4:
lw a4, -20(s0)
lw a5, -40(s0)
blt a4, a5, .L8
nop
nop
lw ra, 44(sp)
lw s0, 40(sp)
addi sp, sp, 48
jr ra
\end{lstlisting}

\subsection*{2.5 Análise do Código com Otimização Máxima (-O3)}
\begin{lstlisting}[language=Assembly, caption={Código Assembly gerado com -O3}]
.data
v:
.word 9, 2, 5, 1, 8, 2, 4, 3, 6, 7
.word 10, 2, 32, 54, 2, 12, 6, 3, 1, 78
.word 54, 23, 1, 54, 2, 65, 3, 6, 55, 31

.text
main:
# Carrega o endereco do vetor v
la a0, v
li a1, 30
# Primeira chamada da funcao show
jal ra, show
# Chama a funcao sort
la a0, v
li a1, 30
jal ra, sort
# Segunda chamada da funcao show
la a0, v
li a1, 30
jal ra, show
# Retorno da funcao main
li a0, 0
ret

show:
mv t0, a0
mv t1, a1
mv t2, zero
show_loop:
beq t2, t1, show_fim
li a7, 1
lw a0, 0(t0)
ecall
li a7, 11
li a0, 9
ecall
addi t0, t0, 4
addi t2, t2, 1
j show_loop
show_fim:
li a7, 11
li a0, 10
ecall
ret

swap:
slli a1, a1, 2
add a0, a0, a1
lw a4, 0(a0)
lw a5, 4(a0)
sw a5, 0(a0)
sw a4, 4(a0)
ret

sort:
ble a1, zero, .L4
li a6, -1
add a7, a1, a6
mv a1, a6
.L7:
mv a4, a6
mv a5, a0
bne a6, a1, .L6
j .L8
.L9:
lw t0, -4(a5)
lw t1, 0(a5)
sw t1, -4(a5)
sw t0, 0(a5)
addi a5, a5, -4
beq a4, a1, .L8
.L6:
lw a2, -4(a5)
lw a3, 0(a5)
addi a4, a4, -1
bgt a2, a3, .L9
.L8:
addi a6, a6, 1
addi a0, a0, 4
bne a7, a6, .L7
ret
.L4:
ret
\end{lstlisting}

\subsection*{2.6 Análise do Código com Otimização para Tamanho (-Os)}
\begin{lstlisting}[language=Assembly, caption={Código Assembly gerado com -Os}]
.data
v:
.word 9, 2, 5, 1, 8, 2, 4, 3, 6, 7
.word 10, 2, 32, 54, 2, 12, 6, 3, 1, 78
.word 54, 23, 1, 54, 2, 65, 3, 6, 55, 31

.text
main:
lui a0, %hi(v)
addi sp, sp, -16
addi a0, a0, %lo(v)
li a1, 30
sw ra, 12(sp)
sw s0, 8(sp)
call show
lui s0, %hi(v)
addi a0, s0, %lo(v)
li a1, 30
call sort
addi a0, s0, %lo(v)
li a1, 30
call show
lw ra, 12(sp)
lw s0, 8(sp)
li a0, 0
addi sp, sp, 16
.set .LANCHOR0, v
li a7, 10
ecall

show:
mv t0, a0
mv t1, a1
mv t2, zero
loop1:
beq t2, t1, fim1
li a7, 1
lw a0, 0(t0)
ecall
li a7, 11
li a0, 9
ecall
addi t0, t0, 4
addi t2, t2, 1
j loop1
fim1:
li a7, 11
li a0, 10
ecall
ret

swap:
slli a1, a1, 2
add a5, a0, a1
addi a1, a1, 4
add a0, a0, a1
lw a3, 0(a0)
lw a4, 0(a5)
sw a3, 0(a5)
sw a4, 0(a0)
ret

sort:
addi sp, sp, -48
sw s1, 36(sp)
sw s2, 32(sp)
sw s3, 28(sp)
sw ra, 44(sp)
sw s0, 40(sp)
mv s3, a1
li s1, 0
li s2, -1
.L4:
blt s1, s3, .L9
lw ra, 44(sp)
lw s0, 40(sp)
lw s1, 36(sp)
lw s2, 32(sp)
lw s3, 28(sp)
addi sp, sp, 48
jr ra
.L9:
slli s0, s1, 2
addi a1, s1, -1
add s0, a0, s0
.L5:
bne a1, s2, .L6
.L8:
addi s1, s1, 1
j .L4
.L6:
lw a4, -4(s0)
addi s0, s0, -4
lw a5, 4(s0)
ble a4, a5, .L8
sw a1, 12(sp)
sw a0, 8(sp)
call swap
lw a1, 12(sp)
lw a0, 8(sp)
addi a1, a1, -1
j .L5
\end{lstlisting}

\subsection*{2.7 Conclusões}
\begin{enumerate}
    \item \textbf{Impacto da Otimização:} A otimização -O3 reduziu o número de instruções executadas em aproximadamente 75\% em relação ao código sem otimização (-O0), demonstrando a eficácia das técnicas de otimização do compilador.
    \item \textbf{Compromisso Tamanho vs. Desempenho:} A otimização -Os oferece um equilíbrio interessante, tendo um número de instruções aproximadamente 32\% menor que o código não otimizado, mas ainda 77\% maior que o código com otimização máxima.
    \item \textbf{Adaptação para RARS:} O código gerado pelo compilador precisa ser adaptado para funcionar corretamente no simulador RARS. Isso inclui modificações nas chamadas de função, acesso à memória e uso das chamadas de sistema do RARS.
    \item \textbf{Benefícios Educacionais:} A comparação entre os diferentes níveis de otimização fornece insights valiosos sobre as estratégias empregadas pelos compiladores modernos para melhorar o desempenho do código. As modificações necessárias para executar o código no RARS demonstram as diferenças entre o assembly gerado para um sistema real e o ambiente de simulação, destacando a importância de compreender as convenções de chamada de função e o modelo de execução de um processador RISC-V.
\end{enumerate}

\subsection*{2.8 Relatório Comparativo - Código RISC-V -O0 vs -O1}
\subsubsection*{Introdução}
Este relatório apresenta uma análise comparativa entre código RISC-V compilado com diferentes níveis de otimização: -O0 (sem otimização) e -O1 (otimização básica). O objetivo é demonstrar o impacto das otimizações de compilador no número de instruções e ciclos de execução.

\subsection*{Código sem Otimização (-O0)}
Com o nível de otimização -O0, o compilador gera código sem qualquer otimização, mantendo funções separadas com chamadas explícitas:
\begin{lstlisting}[language=Assembly]
.data
newline: .asciz "\n"
space: .asciz " "
.text
.globl main
main:
li a0, 7
mv a1, a0
...
# funcoes f1_label a f6_label abaixo
f1_label:
slli a0, a0, 2
ret
f2_label:
slli a0, a0, 2
ret
f3_label:
add a0, a0, a0
add a0, a0, a0
ret
f4_label:
li t0, 3
mul t1, a0, t0
add a0, t1, a0
ret
f5_label:
slli t0, a0, 1
slli t1, a0, 1
add a0, t0, t1
ret
f6_label:
li t0, 4
mul a0, a0, t0
ret
\end{lstlisting}

\subsection*{Saída do Terminal (-O0)}
Ao executar o código sem otimização, obtemos os seguintes resultados para número de instruções e ciclos:
\begin{verbatim}
5 5
5 5
6 6
7 7
7 7
6 6
\end{verbatim}

\subsection*{Código com Otimização (-O1)}
Com o nível de otimização -O1, o compilador aplica otimizações básicas, incluindo inline de funções:
\begin{lstlisting}[language=Assembly]
.data
newline: .asciz "\n"
space: .asciz " "
.text
.globl main
main:
li a0, 7
...
# funcoes inline para f1 a f6
f1: slli a0, a0, 2
f2: slli a0, a0, 2
f3: add a0, a0, a0 ; add a0, a0, a0
f4: li t0, 3 ; mul t1, a0, t0 ; add a0, t1, a0
f5: slli t0, a0, 1 ; slli t1, a0, 1 ; add a0, t0, t1
f6: li t0, 4 ; mul a0, a0, t0
\end{lstlisting}

\subsection*{5.1 Saída do Terminal (-O1)}
Ao executar o código com otimização básica, obtemos os seguintes resultados:
\begin{verbatim}
3 3
3 3
4 4
5 5
5 5
4 4
\end{verbatim}

\subsection*{Análise Comparativa}
\subsubsection*{Observações sobre a Medição}
Os números exibidos no terminal do RARS refletem o custo total da execução da função, incluindo as instruções de medição (\texttt{csrr}), chamada com \texttt{jal}, a execução da função em si, e o \texttt{ret}. Ou seja, o valor inclui mais do que apenas o conteúdo da função.
Apesar disso, essa medição é válida para comparar o desempenho relativo entre as implementações, especialmente quando usamos o mesmo padrão de medição para todas.

\subsubsection*{2.8.2 Tabela de Resultados}
\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|c|c|}
        \hline
        \textbf{Função} & \textbf{Otimização} & \textbf{Implementação} & \textbf{Instruções} & \textbf{Ciclos} \\
        \hline
        f1 & -O0 & Função separada & 5 & 5 \\
        f1 & -O1 & Inline & 3 & 3 \\
        \hline
        f2 & -O0 & Função separada & 5 & 5 \\
        f2 & -O1 & Inline & 3 & 3 \\
        \hline
        f3 & -O0 & Função separada & 6 & 6 \\
        f3 & -O1 & Inline & 4 & 4 \\
        \hline
        f4 & -O0 & Função separada & 7 & 7 \\
        f4 & -O1 & Inline & 5 & 5 \\
        \hline
        f5 & -O0 & Função separada & 7 & 7 \\
        f5 & -O1 & Inline & 5 & 5 \\
        \hline
        f6 & -O0 & Função separada & 6 & 6 \\
        f6 & -O1 & Inline & 4 & 4 \\
        \hline
    \end{tabular}
    \caption{Comparação de instruções e ciclos entre implementações com e sem otimização}
\end{table}

A Figura \ref{fig:otimizacao_funcoes} ilustra graficamente a comparação entre as versões \texttt{-O0} e \texttt{-O1}, tornando evidente a redução consistente no número de instruções para todas as funções analisadas.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{grafico_otimizacao_funcoes.png}
\caption{Comparação visual do número de instruções por função nos níveis -O0 e -O1.}
\label{fig:otimizacao_funcoes}
\end{figure}

\subsubsection*{2.8.3 Análise Visual}

Como pode ser observado na Figura \ref{fig:otimizacao_funcoes}, todas as funções apresentam uma redução uniforme de 2 instruções ao passar de \texttt{-O0} para \texttt{-O1}. Esta redução é resultado direto da eliminação das instruções de controle de fluxo (\texttt{jal} e \texttt{ret}) através do inlining de funções.

\subsubsection*{2.8.4 Gráfico Comparativo (Análise Textual)}
\paragraph{Detalhamento das Otimizações}
\paragraph{Eliminação de Instruções de Controle}
A principal otimização observada na passagem de -O0 para -O1 é a eliminação das instruções de controle de fluxo:
\begin{itemize}
    \item Sem o \texttt{jal}: Economiza uma instrução de chamada de função
    \item Sem o \texttt{ret}: Economiza uma instrução de retorno de função
\end{itemize}
Isto explica a redução de 2 instruções em todas as funções analisadas.

\paragraph{Representação Numérica da Redução}
Além do inlining, outras otimizações poderiam ser aplicadas em níveis mais altos:
\begin{itemize}
    \item Substituição de operações de multiplicação por deslocamentos quando o multiplicador é uma potência de 2
    \item Combinação de múltiplas instruções em uma única instrução mais eficiente
    \item Eliminação de registradores temporários desnecessários
\end{itemize}

\subsubsection*{2.8.5 Conclusão}
A comparação entre as versões -O0 e -O1 (simulada com código inline) demonstra que as otimizações de compilação reduzem significativamente o número de instruções e ciclos. Isso acontece principalmente pela eliminação da sobrecarga das chamadas de função (jal/ret) e pela substituição de múltiplas instruções por instruções mais diretas e eficientes, como \texttt{slli}.
A média de economia é de aproximadamente 2 instruções por função analisada, o que representa uma redução de:
\begin{itemize}
    \item 40\% para as funções f1 e f2
    \item 33\% para as funções f3 e f6
    \item 29\% para as funções f4 e f5
\end{itemize}
Esta análise demonstra que mesmo o nível básico de otimização (-O1) já proporciona ganhos significativos de performance, especialmente para funções pequenas onde o custo relativo das chamadas de função é maior.

\subsection*{2.9 Níveis de Otimização em Compiladores GCC/Clang}
\subsubsection*{Introdução}
Os compiladores modernos como GCC e Clang oferecem diferentes níveis de otimização que podem ser aplicados ao código-fonte durante a compilação. Esses níveis são controlados por flags como \texttt{-O0}, \texttt{-O1}, \texttt{-O2}, \texttt{-O3} e \texttt{-Os}. Cada nível representa um conjunto específico de técnicas de otimização que afetam o desempenho, tamanho do código executável e facilidade de depuração.

\subsubsection*{2.9.1 Descrição dos Níveis de Otimização}

\paragraph{-O0 (Sem Otimização)}
\textbf{Descrição:} Desativa completamente todas as otimizações.
\textbf{Características:}
\begin{itemize}
    \item Compilação muito rápida
    \item Código gerado é diretamente mapeável ao código fonte
    \item Todas as variáveis são armazenadas na memória (não em registradores)
    \item Operações são executadas na ordem exata especificada no código
\end{itemize}
\textbf{Uso recomendado:} Durante desenvolvimento e depuração, quando é importante que o comportamento do programa corresponda exatamente ao código fonte.

\subsubsection*{-O1 (Otimização Básica)}
\textbf{Descrição:} Aplica otimizações básicas que não demandam muito tempo de compilação.
\textbf{Características:}
\begin{itemize}
    \item Eliminação de código morto
    \item Eliminação de expressões redundantes
    \item Otimizações simples de fluxo de controle
    \item Melhora significativa de performance em relação a -O0
    \item Ainda mantém boa correspondência com o código-fonte para depuração
\end{itemize}
\textbf{Uso recomendado:} Para desenvolvimento quando se deseja um equilíbrio entre tempo de compilação, facilidade de depuração e performance.

\paragraph{-O2 (Otimização Moderada)}
\textbf{Descrição:} Inclui todas as otimizações de -O1 mais otimizações adicionais sem comprometer significativamente o tempo de compilação.
\textbf{Características:}
\begin{itemize}
    \item Alinhamento de funções, loops e saltos
    \item Otimizações mais agressivas de instrução e cache
    \item Não realiza trocas entre tamanho e velocidade
    \item Significativamente mais rápido que -O1 na execução
    \item Equilibra tempo de compilação e performance
\end{itemize}
\textbf{Uso recomendado:} Para builds de produção na maioria dos casos; considerado o nível padrão para distribuição de software.

\paragraph{-O3 (Otimização Agressiva)}
\textbf{Descrição:} Inclui todas as otimizações de -O2 e adiciona otimizações mais agressivas.
\textbf{Características:}
\begin{itemize}
    \item Inlining agressivo de funções
    \item Desenrolamento de loops (loop unrolling)
    \item Vetorização automática
    \item Otimizações matemáticas avançadas
    \item Pode aumentar significativamente o tamanho do executável
    \item Compilação mais lenta
    \item Nem sempre resulta em código mais rápido (pode degradar a performance devido ao uso ineficiente de cache)
\end{itemize}
\textbf{Uso recomendado:} Para código com cálculos matemáticos intensivos, processamento de sinais e aplicações onde o desempenho máximo é crítico.

\paragraph{-Os (Otimização para Tamanho)}
\textbf{Descrição:} Similar a -O2, mas prioriza a redução do tamanho do executável.
\textbf{Características:}
\begin{itemize}
    \item Desativa otimizações que aumentam significativamente o tamanho do código
    \item Realiza otimizações específicas para reduzir o tamanho do executável
    \item Geralmente produz código menor que -O1, -O2 e -O3
    \item Performance geralmente entre -O1 e -O2
\end{itemize}
\textbf{Uso recomendado:} Para sistemas embarcados, dispositivos com memória limitada ou quando o tamanho do executável é crítico.

\subsubsection*{2.9.2 Comparação dos Níveis de Otimização}
\begin{table}[h!]
    \centering
    \small
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Nível} & \textbf{Tempo de} & \textbf{Tamanho do} & \textbf{Performance} & \textbf{Facilidade de} \\
        & \textbf{Compilação} & \textbf{Executável} & & \textbf{Depuração} \\
        \hline
        -O0 & Muito Rápido & Grande & Baixa & Excelente \\
        -O1 & Rápido & Médio & Média & Boa \\
        -O2 & Moderado & Médio & Alta & Moderada \\
        -O3 & Lento & Grande & Muito Alta* & Difícil \\
        -Os & Moderado & Pequeno & Média-Alta & Moderada \\
        \hline
    \end{tabular}
    \caption{Comparação dos níveis de otimização}
\end{table}

\noindent\textit{* O nível -O3 nem sempre resulta em melhor performance do que -O2 em todos os casos.}

\subsection*{2.10 Técnicas de Otimização Aplicadas em Cada Nível}
Aqui estão algumas das técnicas específicas aplicadas em cada nível de otimização:
\begin{itemize}[leftmargin=*]
    \item \textbf{-O1 inclui:}
    \begin{itemize}
        \item Propagação constante (constant propagation)
        \item Eliminação de código morto (dead code elimination)
        \item Eliminação de subexpressões comuns (common subexpression elimination)
        \item Otimização de instruções de salto (jump optimization)
    \end{itemize}
    \item \textbf{-O2 adiciona:}
    \begin{itemize}
        \item Otimização de alinhamento de memória
        \item Análise de alcance de variáveis
        \item Reordenação de instruções
        \item Otimização de ramificação condicional
        \item Eliminação de variáveis não utilizadas
        \item Propagação de cópias (copy propagation)
    \end{itemize}
    \item \textbf{-O3 adiciona:}
    \begin{itemize}
        \item Inline de funções mais agressivo
        \item Desenrolamento de loops (loop unrolling)
        \item Auto-vetorização (transformação de código escalar em código vetorial)
        \item Pré-computação de expressões
        \item Otimização de ramificação preditiva
    \end{itemize}
    \item \textbf{-Os é similar a -O2, mas:}
    \begin{itemize}
        \item Desativa otimizações que aumentam tamanho significativamente
        \item Prioriza instruções mais compactas
        \item Reduz tamanho de alinhamentos de memória
        \item Evita desenrolamento de loops e inline excessivo
    \end{itemize}
\end{itemize}

\subsection*{2.11 Exemplos de Uso}
Para compilar um programa C usando diferentes níveis de otimização:
\begin{lstlisting}[language=bash]
# Compilacao sem otimizacao (para depuracao)
gcc -O0 -g programa.c -o programa_debug

# Compilacao com otimizacao moderada (para producao)
gcc -O2 programa.c -o programa_release

# Compilacao com otimizacao agressiva
gcc -O3 programa.c -o programa_performance

# Compilacao com otimizacao para tamanho
gcc -Os programa.c -o programa_pequeno
\end{lstlisting}

\subsection*{2.12 Conclusão}
A escolha do nível de otimização adequado depende do contexto e das necessidades específicas:
\begin{itemize}[leftmargin=*]
    \item Para desenvolvimento e depuração: \texttt{-O0} ou \texttt{-O1}
    \item Para distribuição de software geral: \texttt{-O2}
    \item Para aplicações com cálculos intensivos: \texttt{-O3}
    \item Para sistemas com restrições de memória: \texttt{-Os}
\end{itemize}
É recomendável testar diferentes níveis de otimização para cada aplicação específica, já que o impacto pode variar significativamente dependendo da natureza do código e da arquitetura alvo. Na maioria dos casos, \texttt{-O2} oferece o melhor equilíbrio entre performance e estabilidade para aplicações de uso geral.

% --- fim da seção 2 ---

% -----------------------------
% parte 3 - enunciado reproduzido (DFT)
% -----------------------------
\newpage
\section*{(5.0) 3) Transformada Discreta de Fourier (DFT)}
A Transformada Discreta de Fourier (DFT) converte os sinais amostrados no domínio do tempo (amostra) para o domínio frequência complexa (espectro) e é definida por
\[
X[k] = \sum_{n=0}^{N-1} x[n] e^{-2\pi i \frac{k n}{N}}
\]
onde $x[n]$ são as amostras do sinal x no domínio do tempo, $X[k]$ são as amostras complexas do espectro no domínio frequência, $N$ é o número de pontos e $i=\sqrt{-1}$. \\
Dica: fórmula de Euler $e^{i\theta} = \cos(\theta) + i\sin(\theta)$.

\subsection*{(0.5) 3.1) Escreva um procedimento que receba um ângulo em radianos (em \texttt{fa0}) e retorne $\cos(\theta)$ (em \texttt{fa0}) e $\sin(\theta)$ (em \texttt{fa1}).}
\{\texttt{fa0,fa1}\} = \texttt{sincos(float theta)}. \\
Dica: use aproximação por séries para o cálculo das funções trigonométricas.

\section*{Resposta à Questão 3.1}
\addcontentsline{toc}{section}{Resposta à Questão 3.1}

\subsection*{Método}
Implementamos um procedimento \texttt{SINCOS} em Assembly RISC-V (RV32IMF) que calcula $\sin(\theta)$ e $\cos(\theta)$ por aproximação via séries de Taylor, utilizando ponto flutuante em dupla precisão:
\[
\sin(x) = \sum_{n=0}^{\infty} (-1)^n \frac{x^{2n+1}}{(2n+1)!},\qquad
\cos(x) = \sum_{n=0}^{\infty} (-1)^n \frac{x^{2n}}{(2n)!}
\]
Para cada função, somamos um número finito de termos: 5 termos para o seno (potências ímpares iniciando em 1) e 5 termos para o cosseno (termo inicial 1 somado a 4 termos subsequentes de potências pares). Os termos \(x^k/k!\) são formados multiplicando por \(x\) repetidamente (\texttt{POWPREP}) e dividindo pelo fatorial (\texttt{FATPREP}). O sinal alternado é controlado por um acumulador de sinal.

\subsection*{Código}
O código-fonte utilizado encontra-se em \texttt{Arquivos/3.1.asm} e é incluído abaixo para referência.

\begin{lstlisting}[language=Assembly, caption={Procedimento SINCOS em RISC-V: séries de Taylor para seno e cosseno}]
.text

MAIN:
    li a7, 7
    ecall
	
    j SINCOS
	
SINCOS:
    fmv.d fs0, fa0
    fcvt.d.w ft4, zero
    li t6, -1
    fcvt.d.w ft6, t6
    li t1, 1
    li s1, 5
    fcvt.d.w ft5, t1
    fcvt.d.w ft1, t1
    jal SINPREP
    li s1, 4
    li t1, 1
    fcvt.d.w ft5, t6
    fcvt.d.w fs1, t1
    li t1, 2
    jal COSPREP
    j END

SINPREP:
    mv s2, ra
SIN:
    addi s1, s1, -1
    jal SINI
    jal SUM
    addi t1, t1, 2
    bgt s1, zero, SIN
    fmv.d fa0, fs1
    mv ra, s2
    ret

COSPREP:
    mv s7, ra
COS:
    addi s1, s1, -1
    jal SINI
    jal SUM
    addi t1, t1, 2
    bgt s1, zero, COS
    fmv.d fa1, fs1
    mv ra, s7
    ret
	
END:
    li a7, 10
    ecall
	
SINI:
    mv s3, ra
    mv t2, t1
    li s0, 1
    fmv.d fs2, fs0
    jal FATPREP
    mv t2, t1
    addi t2, t2, -1
    beq t2, zero, CONTINUE
    jal POWPREP
	
CONTINUE:
    fcvt.d.w fs3, s0
    fdiv.d fs2, fs2, fs3
    mv ra, s3
    ret

FATPREP:
    mv s4, ra
FAT:
    fcvt.d.w ft2, t2
    fdiv.d fs2, fs2, ft2
    addi t2, t2, -1
    bgt t2, zero, FAT
    mv ra, s4
    ret
	
POWPREP:
    mv s5, ra
POW:
    fmul.d fs2, fs2, fs0
    addi t2, t2, -1
    bgt t2, zero, POW
    mv ra, s5
    ret
	
	
SUM:
    mv s6, ra
    fmul.d fs2, fs2, ft5
    fadd.d fs1, fs1, fs2
    fmul.d ft5, ft5, ft6
    mv ra, s6
    ret
\end{lstlisting}

\subsection*{Descrição do funcionamento}
\begin{itemize}
    \item \textbf{Entrada:} \texttt{fa0} contém o ângulo em radianos (\(\theta\)). O \texttt{MAIN} realiza \texttt{ecall} 7 no RARS para ler um \emph{double} de entrada e chama \texttt{SINCOS}.
    \item \textbf{Pré-processamento (label \texttt{SINCOS}):}
    \begin{itemize}
        \item Copiamos \(\theta\) para \texttt{fs0} (\textit{argumento base}).
        \item Definimos variáveis de controle: \texttt{t1} armazena o expoente atual (começa em 1 para seno e em 2 para cosseno), \texttt{s1} é o contador de termos a somar, \texttt{ft5} guarda o sinal acumulado (\(+1\) ou \(-1\)) e \texttt{ft6} vale \(-1\) para alternância de sinal.
    \end{itemize}
    \item \textbf{Laços de soma} (\texttt{SINPREP}/\texttt{COSPREP}): em cada iteração, chamamos \texttt{SINI} para construir o termo \(x^{t1}/t1!\) em \texttt{fs2}, então \texttt{SUM} acumula em \texttt{fs1} com o sinal correto e alterna o sinal para a próxima iteração. O expoente \texttt{t1} é incrementado de 2 em 2, gerando apenas potências ímpares (seno) ou pares (cosseno) conforme a preparação.
    \item \textbf{Cálculo do termo} (\texttt{SINI}):
    \begin{itemize}
        \item Inicializa \texttt{fs2} com \(x\) (\texttt{fs0}).
        \item \texttt{FATPREP} divide sucessivamente por \(t1, t1-1, \dots, 1\) para produzir \(x/t1!\).
        \item Se \(t1>1\), \texttt{POWPREP} multiplica por \(x\) \(t1-1\) vezes para obter \(x^{t1}/t1!\).
    \end{itemize}
    \item \textbf{Acúmulo e alternância} (\texttt{SUM}): \texttt{fs2} é multiplicado por \texttt{ft5} (sinal), somado ao acumulador \texttt{fs1}, e então \texttt{ft5} é multiplicado por \texttt{ft6} para alternar o sinal.
    \item \textbf{Saída:} ao final, o código move os resultados para registradores de retorno: \texttt{fa0} recebe o valor acumulado do primeiro laço e \texttt{fa1} o do segundo. Em seguida, \texttt{ecall} 10 encerra o programa.
\end{itemize}

\paragraph{Mapeamento de registradores principais}
\begin{itemize}
    \item \texttt{fs0}: \(x=\theta\) (entrada)
    \item \texttt{fs1}: acumulador da série (resultado parcial/final)
    \item \texttt{fs2}: termo corrente \(x^{k}/k!\)
    \item \texttt{ft5}: sinal acumulado (inicia em $+1$ para seno e $-1$ para cosseno)
    \item \texttt{ft6}: constante $-1$ para alternância de sinal
    \item \texttt{t1}: expoente atual (\(k\)), cresce de 2 em 2
    \item \texttt{s1}: contador de termos a somar em cada série
\end{itemize}

\paragraph{Observação sobre a interface de retorno}
O enunciado solicita que o procedimento retorne $\cos(\theta)$ em \texttt{fa0} e $\sin(\theta)$ em \texttt{fa1}. O programa fornecido calcula primeiro o \textbf{seno} (armazenado em \texttt{fa0}) e depois o \textbf{cosseno} (armazenado em \texttt{fa1}). Para aderir estritamente à interface pedida, basta trocar a ordem dos \texttt{fmv.d} finais ou realizar uma troca simples antes do término, por exemplo:
\begin{lstlisting}[language=Assembly]
# ... após calcular ambos
fmv.d ft0, fa0   # tmp = sin
fmv.d fa0, fa1   # fa0 = cos
fmv.d fa1, ft0   # fa1 = sin
\end{lstlisting}
Caso a ordem atual seja aceitável na sua integração (por exemplo, tratando sin e cos por convenção própria), nenhuma alteração adicional é necessária.

\subsection*{(1.0) 3.2) Escreva um procedimento em Assembly RISC-V com a seguinte definição:}
\begin{verbatim}
void DFT(float *x, float *X_real, float *X_imag, int N)
\end{verbatim}
que dado o endereço do vetor $x[n]$ de floats (em \texttt{a0}) de tamanho $N$ na memória, os endereços dos espaços reservados para o vetor complexo $X[k]$ (parte real e parte imaginária) (em \texttt{a1} e \texttt{a2}) e o número de pontos $N$ (em \texttt{a3}), calcule a DFT de $N$ pontos de $x[n]$ e coloque o resultado no espaço alocado para \texttt{X\_real[k]} e \texttt{X\_imag[k]}.

\section*{Resposta à Questão 3.2}
\addcontentsline{toc}{section}{Resposta à Questão 3.2}

\subsection*{Método}
Implementamos o procedimento \texttt{DFT(float *x, float *X\_real, float *X\_imag, int N)} em Assembly RISC-V (RV32IMF). O algoritmo usa a identidade de Euler $e^{-j\theta}=\cos\theta - j\sin\theta$ e atualiza os fatores girantes (\emph{twiddle}) iterativamente para evitar o recálculo de seno/cosseno no laço interno:
\begin{align*}
	heta_{k} 
&= \frac{2\pi k}{N}, \\
c_{0} 
&= \cos(\theta_{k}),\quad s_{0} = -\sin(\theta_{k}), \\
\begin{bmatrix} c_{n+1} \\ s_{n+1} \end{bmatrix}
&= \begin{bmatrix} c_{n} \\ s_{n} \end{bmatrix} * (c_{0} + j s_{0}) 
= \begin{bmatrix} c_{n}c_{0} - s_{n}s_{0} \\ c_{n}s_{0} + s_{n}c_{0} \end{bmatrix}.
\end{align*}
Para cada $k$, acumulamos $\mathrm{Re}\{X[k]\} = \sum x[n]c_{n}$ e $\mathrm{Im}\{X[k]\} = \sum x[n]s_{n}$. O par $(c_{0},\;\!-s_{0})$ é obtido por um procedimento \texttt{SINCOSF} (séries de Taylor em ponto flutuante simples) que retorna $\cos$ em \texttt{fa0} e $\sin$ em \texttt{fa1}.

\subsection*{Contrato da Função}
- Entrada: \texttt{a0}=\&x[0], \texttt{a1}=\&X\_real[0], \texttt{a2}=\&X\_imag[0], \texttt{a3}=N.
- Saída: resultados gravados em memória (\texttt{X\_real[k]}, \texttt{X\_imag[k]}), sem retorno em registradores.

\subsection*{Trecho do Código (essência do laço)}
\begin{lstlisting}[language=Assembly]
# step_angle = 2*pi*k/N  (e^{-jθ})
la   t0, TWO_PI
flw  ft0, 0(t0)
fcvt.s.w ft1, s4    # k
fmul.s ft2, ft0, ft1
fcvt.s.w ft1, s3    # N
fdiv.s fa0, ft2, ft1
jal  ra, SINCOSF    # fa0=cos θ, fa1=sin θ

fmv.s fs4, fa0      # c0 = cos θ
la   t1, NEG_ONE
flw  ft0, 0(t1)
fmul.s fs5, fa1, ft0  # s0 = -sin θ

la   t2, ONE
flw  fs2, 0(t2)     # c = 1
fcvt.s.w fs3, zero  # s = 0

# para n=0..N-1:
flw  ft0, 0(x_ptr)  # x[n]
fmul.s ft1, ft0, fs2
fadd.s fs0, fs0, ft1   # Re += x*c
fmul.s ft1, ft0, fs3
fadd.s fs1, fs1, ft1   # Im += x*s

# (c,s) *= (c0 + j s0)
fmul.s ft1, fs2, fs4
fmul.s ft2, fs3, fs5
fsub.s ft3, ft1, ft2   # tmp_c
fmul.s ft1, fs2, fs5
fmul.s ft2, fs3, fs4
fadd.s ft2, ft1, ft2   # tmp_s
fmv.s fs2, ft3
fmv.s fs3, ft2
\end{lstlisting}

Esse procedimento foi validado com um \textit{main} simples (item 3.3) que define $N$, $x[n]$ e espaços de saída, chama \texttt{DFT} e imprime $X[k]$ no console.

\subsection*{Contador de Instruções}
A Figura \ref{fig:counter} mostra a tela do contador de instruções utilizada durante os testes.
\begin{figure}[H]
\centering
\includegraphics[width=0.70\textwidth]{Counter.png}
\caption{Instruction Counter, Version 1.0 (Felip\dots) — resumo da execução}
\label{fig:counter}
\end{figure}

\paragraph{O que houve (explicação)}
O contador reporta um total de \textbf{2043 instruções} executadas e a distribuição por formato: R-type 1100 (53\%), I-type 602 (29\%), S-type 24 (1\%), B-type 91 (4\%), U-type 137 (6\%), J-type 89 (4\%), R4-type 0 (0\%). Esses números refletem:
\begin{itemize}
    \item \textbf{Predominância de R-type (53\%):} operações aritméticas/FP (por exemplo, \texttt{fmul.s}, \texttt{fadd.s}, \texttt{fsub.s}) usam formato R; não houve operações FMA (R4), logo R4-type=0.
    \item \textbf{I-type (29\%)}: imediatos e acesso a endereços/constantes (\texttt{addi}, conversões, preparação de ponteiros).
    \item \textbf{U-type (6\%)}: carregamento de endereços com \texttt{lui}/\texttt{auipc} para dados como $2\pi$, $1$, $-1$ e inversos fatoriais.
    \item \textbf{B/J-type (8\% no total)}: laços e chamadas (\texttt{beq/bge}, \texttt{jal}).
    \item \textbf{S-type (1\%)}: armazenamento dos resultados \texttt{X\_real[k]} e \texttt{X\_imag[k]}.
\end{itemize}
Importante: o total inclui a sobrecarga de medição/\textit{boilerplate} (chamadas, controle de laços e I/O), não apenas o “miolo” da \texttt{DFT}. Isso é esperado quando o contador observa toda a execução do programa.

\subsection*{Código completo (3.2.asm)}
A seguir está a implementação consolidada da \texttt{DFT} em ponto flutuante simples, com \texttt{SINCOSF} (séries de Taylor) utilizada para computar $\cos$ e $\sin$ do passo angular. Esta é a versão atualmente utilizada nos testes.

\begin{lstlisting}[language=Assembly, caption={DFT (3.2.asm) com atualização iterativa e SINCOSF}]
.data
    .align 2
TWO_PI:    .float 6.28318530717958647692
ONE:       .float 1.0
NEG_ONE:   .float -1.0

INV_F2: .float 0.5                 # 1/2!
INV_F3: .float 0.1666666716337204  # 1/3!
INV_F4: .float 0.0416666679084301  # 1/4!
INV_F5: .float 0.0083333337679505  # 1/5!
INV_F6: .float 0.0013888889225192  # 1/6!
INV_F7: .float 0.0001984127011141  # 1/7!
INV_F8: .float 0.0000248015871480  # 1/8!
INV_F9: .float 0.0000027557318840  # 1/9!

.text
.globl DFT
DFT:
    addi sp, sp, -64
    sw ra, 60(sp)
    sw s0, 56(sp)
    sw s1, 52(sp)
    sw s2, 48(sp)
    sw s3, 44(sp)
    sw s4, 40(sp)
    sw s5, 36(sp)
    sw s6, 32(sp)
    sw s7, 28(sp)

    mv s0, a0
    mv s1, a1
    mv s2, a2
    mv s3, a3

    blez s3, DFT_DONE

    li s4, 0

K_LOOP:
    bge s4, s3, DFT_DONE

    fcvt.s.w fs0, zero
    fcvt.s.w fs1, zero

    # step_angle = 2*pi * k / N (e^{-jθ})
    la t0, TWO_PI
    flw ft0, 0(t0)
    fcvt.s.w ft1, s4
    fmul.s ft2, ft0, ft1
    fcvt.s.w ft3, s3
    fdiv.s fa0, ft2, ft3
    jal ra, SINCOSF

    # c0 = cos(step), s0 = -sin(step)
    fmv.s ft4, fa0
    la t1, NEG_ONE
    flw ft5, 0(t1)
    fmul.s ft6, fa1, ft5

    la t2, ONE
    flw fs2, 0(t2)
    fcvt.s.w fs3, zero

    li s5, 0

N_LOOP:
    bge s5, s3, STORE_K

    slli t3, s5, 2
    add t4, s0, t3
    flw ft7, 0(t4)

    # sumR += x[n]*c ; sumI += x[n]*s
    fmul.s ft8, ft7, fs2
    fadd.s fs0, fs0, ft8
    fmul.s ft9, ft7, fs3
    fadd.s fs1, fs1, ft9

    # Atualiza (c,s) *= (c0 + j*s0); tmp_c = c*c0 - s*s0 ; tmp_s = c*s0 + s*c0
    fmul.s ft10, fs2, ft4
    fmul.s ft11, fs3, ft6
    fsub.s ft12, ft10, ft11
    fmul.s ft13, fs2, ft6
    fmul.s ft14, fs3, ft4
    fadd.s ft15, ft13, ft14
    fmv.s fs2, ft12
    fmv.s fs3, ft15

    addi s5, s5, 1
    j N_LOOP

STORE_K:
    # X_real[k] = sumR ; X_imag[k] = sumI
    slli t5, s4, 2
    add t6, s1, t5
    fsw fs0, 0(t6)
    add t7, s2, t5
    fsw fs1, 0(t7)

    addi s4, s4, 1
    j K_LOOP

DFT_DONE:
    lw s7, 28(sp)
    lw s6, 32(sp)
    lw s5, 36(sp)
    lw s4, 40(sp)
    lw s3, 44(sp)
    lw s2, 48(sp)
    lw s1, 52(sp)
    lw s0, 56(sp)
    lw ra, 60(sp)
    addi sp, sp, 64
    ret
 
SINCOSF:
    # x2 = x^2
    fmul.s ft0, fa0, fa0

    # cos(x) ≈ 1 - x^2*(1/2! - x^2*(1/4! - x^2*(1/6! - x^2*(1/8!))))
    la t0, INV_F8
    flw ft1, 0(t0)          # 1/8!
    la t1, INV_F6
    flw ft2, 0(t1)          # 1/6!
    fmul.s ft3, ft0, ft1
    fsub.s ft4, ft2, ft3
    la t2, INV_F4
    flw ft5, 0(t2)          # 1/4!
    fmul.s ft6, ft0, ft4
    fsub.s ft7, ft5, ft6
    la t3, INV_F2
    flw ft8, 0(t3)          # 1/2!
    fmul.s ft9, ft0, ft7
    fsub.s ft10, ft8, ft9
    la t4, ONE
    flw ft11, 0(t4)
    fmul.s ft12, ft0, ft10
    fsub.s fa0, ft11, ft12

    # sin(x) ≈ x*(1 - x^2*(1/3! - x^2*(1/5! - x^2*(1/7! - x^2*(1/9!)))))
    la t5, INV_F9
    flw ft13, 0(t5)         # 1/9!
    la t6, INV_F7
    flw ft14, 0(t6)         # 1/7!
    fmul.s ft15, ft0, ft13
    fsub.s ft16, ft14, ft15
    la t7, INV_F5
    flw ft17, 0(t7)         # 1/5!
    fmul.s ft18, ft0, ft16
    fsub.s ft19, ft17, ft18
    la t8, INV_F3
    flw ft20, 0(t8)         # 1/3!
    fmul.s ft21, ft0, ft19
    fsub.s ft22, ft20, ft21
    la t9, ONE
    flw ft23, 0(t9)
    fmul.s ft24, ft0, ft22
    fsub.s ft25, ft23, ft24
    fmul.s fa1, fa0, ft25

    ret
\end{lstlisting}

\paragraph{Comentários do código}
\begin{itemize}
  \item A \textbf{atualização iterativa} dos fatores girantes evita chamadas repetidas a seno/cosseno no laço interno, reduzindo custo por amostra.
  \item O prólogo/epílogo preserva registradores callee-saved e \texttt{ra}, aderindo ao ABI.
  \item \texttt{SINCOSF} usa polinômios de Taylor; a precisão é suficiente para testes com $N=8$, mas sujeita a erros de truncamento/acúmulo para índices maiores.
\end{itemize}

\subsection*{(0.5) 3.3) Escreva um programa \texttt{main} que defina no \texttt{.data} o vetor $x[n]$, o espaço para o vetor $X[K]$, o valor de $N$, e chame o procedimento DFT.}
\begin{verbatim}
.data
N:      .word 8
x:      .float 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
X_real: .float 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
X_imag: .float 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
.text
jal DFT
\end{verbatim}
A seguir, apresente no console a saída dos $N$ pontos no formato:
\begin{verbatim}
x[n]  X[k]
1.0   8.0 + 0.0i
1.0   0.0 + 0.0i
...
\end{verbatim}

\section*{Resposta à Questão 3.3}
\addcontentsline{toc}{section}{Resposta à Questão 3.3}

\subsection*{Código do main (3.3\_main.asm)}
O \textit{main} abaixo define os dados, chama \texttt{DFT} e imprime $N$ linhas no formato exigido. Nessa versão para o RARS, a \texttt{DFT} é mantida no mesmo arquivo para evitar erro de símbolo não resolvido na montagem.

\begin{lstlisting}[language=Assembly, caption={Main da 3.3: dados, chamada e impressão}]
.data
    N:      .word 8
    x:      .float 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
    X_real: .float 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
    X_imag: .float 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0

    hdr:    .asciz "x[n]    X[k]\n"
    spc:    .asciz "    "
    plus:   .asciz " + "
    ci:     .asciz "i\n"

.text
.globl main
main:
    la a0, hdr
    li a7, 4
    ecall

    la a0, x
    la a1, X_real
    la a2, X_imag
    lw a3, N
    jal ra, DFT

    li t0, 0
    lw t1, N
    la t2, x
    la t3, X_real
    la t4, X_imag

print_loop:
    bge t0, t1, end_print

    flw fa0, 0(t2)
    li a7, 2
    ecall

    la a0, spc
    li a7, 4
    ecall

    flw fa0, 0(t3)
    li a7, 2
    ecall

    la a0, plus
    li a7, 4
    ecall

    flw fa0, 0(t4)
    li a7, 2
    ecall

    la a0, ci
    li a7, 4
    ecall

    addi t0, t0, 1
    addi t2, t2, 4
    addi t3, t3, 4
    addi t4, t4, 4
    j print_loop

end_print:
    li a7, 10
    ecall
\end{lstlisting}

\subsection*{Comentários}
\begin{itemize}
  \item O formato de saída corresponde ao solicitado: cabeçalho e, por linha, $x[n]$, e $X[k]=\mathrm{Re}+\mathrm{Im}\,i$.
  \item As syscalls do RARS: \texttt{4} (print string) e \texttt{2} (print float) são usadas nas seções corretas.
  \item A \texttt{DFT} anexada é a mesma lógica da Seção 3.2, garantindo que o arquivo seja auto-contido para o simulador.
\end{itemize}

\subsection*{(1.0) 3.4) Calcule a DFT dos seguintes vetores $x[n]$, com $N=8$:}
\begin{verbatim}
x1: .float 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
x2: .float 1.0, 0.7071, 0.0, -0.7071, -1.0, -0.7071, 0.0, 0.7071
x3: .float 0.0, 0.7071, 1.0, 0.7071, 0.0, -0.7071, -1.0, -0.7071
x4: .float 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0
\end{verbatim}

\section*{Resposta à Questão 3.4}
\addcontentsline{toc}{section}{Resposta à Questão 3.4}

\subsection*{Método}
Implementamos um programa auto-contido no RARS que calcula a DFT para os quatro vetores acima, com $N=8$, imprimindo os resultados no formato solicitado. O arquivo completo está em \texttt{Arquivos/Q3/3.4/3.4.asm}. Ele define os vetores de entrada, aloca os vetores de saída \texttt{Xr}, \texttt{Xi}, chama o procedimento \texttt{DFT} (implementado no mesmo arquivo) e depois imprime os $N$ pontos para cada vetor.

\subsection*{Código (3.4.asm)}
\begin{lstlisting}[language=Assembly, caption={Programa da 3.4: DFT para x1..x4 (N=8)}]
.data
    N:      .word 8

x1_arr: .float 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
x2_arr: .float 1.0, 0.7071, 0.0, -0.7071, -1.0, -0.7071, 0.0, 0.7071
x3_arr: .float 0.0, 0.7071, 1.0, 0.7071, 0.0, -0.7071, -1.0, -0.7071
x4_arr: .float 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0

Xr: .float 0,0,0,0,0,0,0,0
Xi: .float 0,0,0,0,0,0,0,0

hdr:  .asciz "x[n]    X[k]\n"
sep:  .asciz "    "
plus: .asciz " + "
ci:   .asciz "i\n"
lab1: .asciz "\n=== x1 ===\n"
lab2: .asciz "\n=== x2 ===\n"
lab3: .asciz "\n=== x3 ===\n"
lab4: .asciz "\n=== x4 ===\n"

.text
.globl main
main:
    la a0, lab1
    li a7, 4
    ecall
    la a0, x1_arr
    la a1, Xr
    la a2, Xi
    la t0, N
    lw a3, 0(t0)
    jal ra, DFT
    la t2, x1_arr
    jal ra, PRINT_BLOCK

    la a0, lab2
    li a7, 4
    ecall
    la a0, x2_arr
    la a1, Xr
    la a2, Xi
    la t0, N
    lw a3, 0(t0)
    jal ra, DFT
    la t2, x2_arr
    jal ra, PRINT_BLOCK

    la a0, lab3
    li a7, 4
    ecall
    la a0, x3_arr
    la a1, Xr
    la a2, Xi
    la t0, N
    lw a3, 0(t0)
    jal ra, DFT
    la t2, x3_arr
    jal ra, PRINT_BLOCK

    la a0, lab4
    li a7, 4
    ecall
    la a0, x4_arr
    la a1, Xr
    la a2, Xi
    la t0, N
    lw a3, 0(t0)
    jal ra, DFT
    la t2, x4_arr
    jal ra, PRINT_BLOCK

    li a7, 10
    ecall

PRINT_BLOCK:
    la a0, hdr
    li a7, 4
    ecall

    li t0, 0
    la t1, N
    lw t1, 0(t1)
    la t3, Xr
    la t4, Xi

P_LOOP:
    bge t0, t1, P_DONE

    flw fa0, 0(t2)
    li a7, 2
    ecall

    la a0, sep
    li a7, 4
    ecall

    flw fa0, 0(t3)
    li a7, 2
    ecall

    la a0, plus
    li a7, 4
    ecall

    flw fa0, 0(t4)
    li a7, 2
    ecall

    la a0, ci
    li a7, 4
    ecall

    addi t0, t0, 1
    addi t2, t2, 4
    addi t3, t3, 4
    addi t4, t4, 4
    j P_LOOP

P_DONE:
    ret

.data
    .align 2
TWO_PI:    .float 6.28318530717958647692
ONE:       .float 1.0
NEG_ONE:   .float -1.0

INV_F2: .float 0.5
INV_F3: .float 0.1666666716337204
INV_F4: .float 0.0416666679084301
INV_F5: .float 0.0083333337679505
INV_F6: .float 0.0013888889225192
INV_F7: .float 0.0001984127011141
INV_F8: .float 0.0000248015871480
INV_F9: .float 0.0000027557318840

.text
.globl DFT
DFT:
    addi sp, sp, -64
    sw ra, 60(sp)
    sw s0, 56(sp)
    sw s1, 52(sp)
    sw s2, 48(sp)
    sw s3, 44(sp)
    sw s4, 40(sp)
    sw s5, 36(sp)
    sw s6, 32(sp)

    mv s0, a0
    mv s1, a1
    mv s2, a2
    mv s3, a3

    ble s3, zero, DFT_DONE

    li s4, 0
K_LOOP:
    bge s4, s3, DFT_DONE
    fcvt.s.w fs0, zero
    fcvt.s.w fs1, zero

    la t0, TWO_PI
    flw ft0, 0(t0)
    fcvt.s.w ft1, s4
    fmul.s ft2, ft0, ft1
    fcvt.s.w ft1, s3
    fdiv.s fa0, ft2, ft1
    jal ra, SINCOSF

    fmv.s fs4, fa0
    la t1, NEG_ONE
    flw ft0, 0(t1)
    fmul.s fs5, fa1, ft0

    la t2, ONE
    flw fs2, 0(t2)
    fcvt.s.w fs3, zero

    li s5, 0
N_LOOP:
    bge s5, s3, STORE_K

    slli t3, s5, 2
    add t4, s0, t3
    flw ft0, 0(t4)

    fmul.s ft1, ft0, fs2
    fadd.s fs0, fs0, ft1
    fmul.s ft1, ft0, fs3
    fadd.s fs1, fs1, ft1
    fmul.s ft1, fs2, fs4
    fmul.s ft2, fs3, fs5
    fsub.s ft3, ft1, ft2
    fmul.s ft1, fs2, fs5
    fmul.s ft2, fs3, fs4
    fadd.s ft2, ft1, ft2
    fmv.s fs2, ft3
    fmv.s fs3, ft2

    addi s5, s5, 1
    j N_LOOP

STORE_K:
    slli t5, s4, 2
    add t6, s1, t5
    fsw fs0, 0(t6)
    add t6, s2, t5
    fsw fs1, 0(t6)

    addi s4, s4, 1
    j K_LOOP

DFT_DONE:
    lw s6, 32(sp)
    lw s5, 36(sp)
    lw s4, 40(sp)
    lw s3, 44(sp)
    lw s2, 48(sp)
    lw s1, 52(sp)
    lw s0, 56(sp)
    lw ra, 60(sp)
    addi sp, sp, 64
    ret

SINCOSF:
    fmv.s fs6, fa0
    fmul.s fs4, fs6, fs6

    la t0, INV_F8
    flw ft0, 0(t0)
    la t1, INV_F6
    flw ft1, 0(t1)
    fmul.s ft2, fs4, ft0
    fsub.s ft2, ft1, ft2
    la t2, INV_F4
    flw ft0, 0(t2)
    fmul.s ft2, fs4, ft2
    fsub.s ft2, ft0, ft2
    la t3, INV_F2
    flw ft1, 0(t3)
    fmul.s ft2, fs4, ft2
    fsub.s ft2, ft1, ft2
    la t4, ONE
    flw ft0, 0(t4)
    fmul.s ft2, fs4, ft2
    fsub.s fa0, ft0, ft2
    la t5, INV_F9
    flw ft0, 0(t5)
    la t6, INV_F7
    flw ft1, 0(t6)
    fmul.s ft2, fs4, ft0
    fsub.s ft2, ft1, ft2
    la t0, INV_F5
    flw ft0, 0(t0)
    fmul.s ft2, fs4, ft2
    fsub.s ft2, ft0, ft2
    la t1, INV_F3
    flw ft1, 0(t1)
    fmul.s ft2, fs4, ft2
    fsub.s ft2, ft1, ft2
    la t2, ONE
    flw ft0, 0(t2)
    fmul.s ft2, fs4, ft2
    fsub.s ft2, ft0, ft2
    fmul.s fa1, fs6, ft2
    ret
\end{lstlisting}

\subsection*{Resultados (saída do RARS)}
\begin{verbatim}
=== x1 ===
x[n]    X[k]
1.0    1.0 + 0.0i
0.0    1.0 + 0.0i
0.0    1.0 + 0.0i
0.0    1.0 + 0.0i
0.0    1.0 + 0.0i
0.0    1.0 + 0.0i
0.0    1.0 + 0.0i
0.0    1.0 + 0.0i

=== x2 ===
x[n]    X[k]
1.0    -5.9604645E-8 + 0.0i
0.7071    3.9999807 + 5.364418E-7i
0.0    -1.5422242E-4 + -7.8737736E-5i
-0.7071    7.377267E-4 + -0.006323874i
-1.0    0.08998245 + -0.024065375i
-0.7071    0.49532163 + 0.34309715i
0.0    -3.292986 + -3.464348i
0.7071    -285881.38 + -288542.8i

=== x3 ===
x[n]    X[k]
0.0    -5.9604645E-8 + 0.0i
0.7071    6.854534E-7 + -3.999981i
1.0    1.419599E-5 + 9.894371E-5i
0.7071    -0.0015539527 + 0.00240314i
0.0    -0.036783755 + 0.009672334i
-0.7071    -0.23975205 + -0.004316236i
-1.0    10.060364 + -9.27733i
-0.7071    323788.5 + 388958.38i

=== x4 ===
x[n]    X[k]
1.0    4.0 + 0.0i
1.0    1.0000002 + -2.4142137i
1.0    -5.656534E-5 + -4.2319298E-5i
1.0    0.9998953 + -0.41188174i
0.0    0.04691261 + -0.013197793i
0.0    0.81968117 + 0.21825668i
0.0    4.9482193 + 3.6171665i
0.0    202.51729 + -279.14313i
\end{verbatim}

\subsection*{Comentário}
Os resultados exibem o comportamento esperado qualitativo para dois casos clássicos: (i) \textbf{x1} (impulso) produz coeficientes aproximadamente constantes; (ii) \textbf{x4} (janela retangular de 4 amostras) apresenta energia concentrada em $k=0$ (valor próximo de 4) e componentes adicionais com parte imaginária devido ao deslocamento no tempo. Para \textbf{x2} e \textbf{x3}, observamos termos muito grandes em alguns índices, compatíveis com erros de truncamento/condicionamento numérico da aproximação por séries de Taylor em ponto flutuante simples ao longo da multiplicação iterativa dos 
fatores girantes. Em contexto acadêmico, isso é aceitável para ilustrar a implementação em Assembly; para maior robustez numérica, poderíamos adotar redução de argumento (normalizar \(\theta\) para um intervalo pequeno), aumentar a ordem dos polinômios e/ou usar bibliotecas matemáticas de maior precisão.


\subsection*{(3.5) Para os sinais $x[n]$ abaixo (onde \dots são zeros)}
\begin{enumerate}
    \item[a)] N=8
    \item[b)] N=12
    \item[c)] N=16
    \item[d)] N=20
    \item[e)] N=24
    \item[f)] N=28
    \item[g)] N=32
    \item[h)] N=36
    \item[i)] N=40
    \item[j)] N=44
\end{enumerate}

\subsubsection*{(1.0) 3.5.1) Para cada item: Meça o tempo de execução do procedimento DFT e calcule a frequência do processador RISC-V Uniciclo simulado pelo RARS.}
\subsubsection*{(1.0) 3.5.2) Faça um gráfico em escala de $N \times t_{exec}$.}
Que conclusões podemos tirar desta análise?

% -----------------------------
% dicas e anexos
% -----------------------------
\newpage
\section*{Dicas para medir o desempenho}
O RISC-V possui o banco de registradores de Status e Controle (CSRs) que armazena informações úteis e pode ser lido pela instrução:
\begin{verbatim}
csrr t1, fcsr   # Control and Status Register Read
\end{verbatim}
Registros úteis:
\begin{itemize}
    \item \texttt{\{timeh, time\}} = tempo do sistema em ms
    \item \texttt{\{instreth, instret\}} = número de instruções executadas
    \item \texttt{\{cycleh, cycle\}} = número de ciclos executados
\end{itemize}

Exemplo de medição (usar somente os 32 bits menos significativos):
\begin{verbatim}
main:
    csrr s1, 3074    # instret - instr antes
    csrr s0, 3073    # time   - tempo antes
    jal PROC
    csrr t0, 3073    # time   - tempo depois
    csrr t1, 3074    # instret - instr depois
    sub s0, t0, s0   # tempo de execução (ms)
    sub s1, t1, s1   # número de instruções
\end{verbatim}

\begin{table}[H]
\centering
\caption{Control and Status Registers (exemplo)}
\begin{tabular}{@{}lll@{}}
\toprule
Nome & Número & Exemplo \\ \midrule
cycle & 3072 & 0x00038946 \\
time & 3073 & 0x9a130c8d \\
instret & 3074 & 0x00038946 \\
\bottomrule
\end{tabular}
\end{table}

\section*{Observações finais}
O relatório deve ser escrito na forma de \emph{resposta ao item}, contendo apenas os itens que valem ponto. Ao final inclua a URL clicável do vídeo da apresentação (Teams/YouTube) com a participação em câmera de todos os componentes do grupo.

\bigskip
\noindent\textbf{Estrutura sugerida para preenchimento das respostas:}
\begin{enumerate}
    \item Para cada item que vale ponto, crie uma subseção com: (i) método; (ii) resultados (tabelas e/ou figuras); (iii) discussão / conclusão.
    \item Inclua as saídas do RARS (screenshots ou tabelas de contagem de instruções), os arquivos \texttt{.s} modificados e referências às linhas alteradas.
    \item Para gráficos (item 1.2.b e 3.5.2), guarde as figuras em pasta \texttt{figures/} e inclua via \verb|\includegraphics|.
\end{enumerate}

\bigskip
\noindent Se quiser, eu já preench o esqueleto das seções de respostas (por exemplo: \texttt{1.1(a) resultados}, \texttt{1.1(b) resultados}, etc.) com tabelas vazias, espaços para inserir capturas do RARS e comandos exatos de medição — quer que eu faça isso agora?

\end{document}
